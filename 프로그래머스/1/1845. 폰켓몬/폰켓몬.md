
```Python
def solution(nums):
    noRepeat={}
    #일일히 중복제거를 한다
    for num in nums:
        noRepeat[num]=True
    length=len(noRepeat)
    if length>(len(nums)//2):
        return len(nums)//2
    else: return length

```


### [1단계 답변] : 제출된 코드 분석 및 CS 검증

#### **1. ⚔️ 코딩 테스트 관점 비판**

- **시간 복잡도:** 입력 배열 `nums`를 한 번 순회하며 Dictionary(`noRepeat`)를 구성하므로 $O(N)$입니다. 이후 길이를 구하고 비교하는 연산은 $O(1)$입니다. $N=10,000$일 때 충분히 빠릅니다.
- **공간 복잡도:** 최악의 경우 모든 폰켓몬 종류가 다를 때 Dictionary에 $N$개의 키가 저장되므로 $O(N)$입니다. 이 또한 메모리 제한 내에서 안전합니다.
- **총평:** 로직은 **합격점**입니다. 하지만 파이썬의 강력한 내장 함수들을 놔두고 C스타일로 코드를 작성한 점이 아쉽습니다.
    

#### **2. 💩 실무 코드 관점 리뷰 (Clean Code)**

이 코드를 PR(Pull Request)로 올렸다면, 다음과 같은 이유로 "수정 요청(Change Request)"을 드렸을 겁니다.

- **불필요한 자료구조 오용:** `noRepeat = {}` 처럼 딕셔너리를 선언하고 `True`라는 더미(Dummy) 값을 넣고 계십니다. 파이썬에는 **`set()` (집합)**이라는, 중복 제거를 위한 전용 자료구조가 있습니다. 의도가 불분명한 딕셔너리 사용은 가독성을 해칩니다.
- **변수명 (`noRepeat`, `length`):** `noRepeat`는 자료구조의 특성을 설명하는 이름이지, 담긴 **데이터의 본질**을 설명하지 못합니다. `uniquePokemonTypes`나 `speciesSet` 같은 이름이 더 적절합니다.
- **Verbose(장황한) 로직:** `if length > … else …` 구문은 로직의 흐름을 끊습니다. 두 값 중 작은 것을 선택하는 것이니 `min()` 함수를 쓰는 것이 훨씬 직관적입니다.
    

#### **3. 🧠 CS 기본기 검증 (Why & Principle)**

작성하신 코드에서 사용한 Dictionary(Java의 HashMap, Python의 dict)의 원리를 묻는 면접 질문입니다.

> **Q1. 해시 테이블(Hash Table)에서 데이터를 조회할 때 시간 복잡도가 $O(1)$인 원리를 설명해보세요.**
>
> - **모범 답안:** 해시 테이블은 Key 값을 **해시 함수(Hash Function)**에 넣어 고유한 인덱스(해시값)를 생성하고, 이 인덱스를 통해 배열(Bucket)에 직접 접근하기 때문입니다. 따라서 데이터의 크기와 상관없이 즉시 접근이 가능합니다.
>     

> **Q2. 만약 서로 다른 Key가 우연히 같은 해시값(인덱스)을 가질 경우(Hash Collision), 어떻게 해결합니까?**
>
> - **모범 답안:** 대표적으로 두 가지 방법이 있습니다.
>     
>     1. **Chaining (체이닝):** 같은 해시값을 가진 데이터를 연결 리스트(Linked List)로 줄줄이 연결하여 저장하는 방식입니다. (Java HashMap이 이 방식을 사용하며, 데이터가 많아지면 Red-Black Tree로 변환합니다.)
>         
>     2. **Open Addressing (개방 주소법):** 비어있는 다른 인덱스를 찾아 데이터를 저장하는 방식입니다.
>         

#### **4. 💎 코딩 테스트용 모범 답안 (Modern Java)**

신입 개발자라면 **Stream API**를 활용해 "나는 데이터 처리를 선언적으로 할 줄 안다"는 것을 보여주는 것이 좋습니다.

```Java
import java.util.Arrays;

class Solution {
    public int solution(int[] nums) {
        // 1. 중복을 제거한 폰켓몬 종류의 수 계산 (Stream API 활용)
    //distinct(): 내부적으로 HashSet을 사용하여 중복 제거 (O(N))
        long uniqueTypes = Arrays.stream(nums)
                                 .distinct()
                                 .count();
        // 2. 가질 수 있는 최대 마리 수 (N/2)
        int maxPickable = nums.length / 2;
        // 3. 둘 중 더 작은 값이 정답 (Math.min 활용하여 if-else 제거)
        return (int) Math.min(uniqueTypes, maxPickable);
    }
}
```

> **📌 Java vs Python 문법 포인트:**
>
> - **타입 명시:** Python은 `def solution(nums):`로 끝이지만, Java는 `int[]`, `int`, `long` 등 데이터 타입을 엄격하게 정의해야 합니다. 이는 컴파일 단계에서 오류를 잡아주어 대규모 협업에 유리합니다.
>     
> - **Stream API:** Python의 `set(nums)` 한 줄이 Java에서는 `.stream().distinct().count()`로 표현됩니다. 다소 길어 보이지만, 데이터 처리의 파이프라인(흐름)이 명확해지는 장점이 있습니다.
>     
---
### [2단계 답변] : 🚨 신입 사원 업무 시뮬레이션 (Junior Reality)

**"자, 신입 사원님! 코테에선 그게 100점짜리 정답이지만, 실무에서 데이터를 애플리케이션 메모리에 모두 올리면 서버가 터집니다. 인프라를 믿고 일을 맡겨봅시다."**

---

#### **1. 🏢 업무 배경 파악 (Context)**

이 문제는 실무에서 **"실시간 인기 게임 아이템 드롭 분석 대시보드"** 기능으로 각색할 수 있습니다.

- **상황:** 우리 게임 서버에서 초당 수만 개의 아이템이 드롭되고 있습니다.
- **요구사항:** 운영팀이 모니터링할 수 있도록 **"현재까지 드롭된 아이템의 '종류(Unique Type)' 개수가 전체 드롭량의 절반을 넘지 않도록"** 밸런스를 감시해야 합니다.
- **문제점:** 지금 작성하신 코드처럼 모든 드롭 로그(`nums`)를 애플리케이션 서버의 메모리(List/Map)로 가져와서 중복을 제거하면, 트래픽이 몰릴 때 **OOM(Out Of Memory)** 에러로 서버가 다운됩니다.
    

---

#### **2. 💡 사수의 귓속말 (Engineer's Mindset: Offloading)**

- **알고리즘 vs 인프라:**

> "지금 작성하신 `solution(nums)` 함수는 데이터를 서버로 가져와서(Fetch) 가공하고 있습니다. 하지만 우리가 필요한 건 데이터 자체가 아니라 **'유니크한 개수(Cardinality)'**입니다. 이건 애플리케이션이 아니라 **`[Caching Layer (Redis)]`**가 가장 잘하는 일입니다."

- **판단의 기준 (Why Redis?):**
    1. **메모리 효율:** 자바 힙(Heap) 메모리에 수십만 개의 객체를 쌓는 것보다, Redis의 최적화된 자료구조를 쓰는 게 낫습니다.
    2. **분산 환경:** 서버가 여러 대(Scale-out)일 때, 각 서버의 메모리가 아니라 **중앙화된 저장소(Redis)**에서 카운팅해야 정확한 집계가 가능합니다.

---

#### **3. 🛠️ 기술적 의사결정 (Architecture Decision)**

- 솔루션 제안:
    
    "이 문제는 **Caching Layer (Redis)**의 Set 자료구조를 사용하는 것이 정석입니다."
    
    (만약 데이터가 수억 건이라 오차를 허용하고 메모리를 극도로 아껴야 한다면 HyperLogLog를 쓰겠지만, 지금처럼 정확한 N/2 비교가 필요할 땐 Set이 맞습니다.)
    
- 코드 대체 (Java Spring Boot + RedisTemplate):
    
    내 코드의 HashMap 로직을 Redis 명령어로 대체합니다.

```java
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;

@Service
public class DropAnalysisService {

    private final RedisTemplate<String, String> redisTemplate;
    // 키 생성 규칙: "game:drop:{eventId}"
    private static final String KEY_PREFIX = "game:drop:";
    
    public DropAnalysisService(RedisTemplate<String, String> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    // 기존 solution 함수를 대체하는 실무 로직
    public long analyzeDropVariety(String eventId, long totalDropCount) {
        String key = KEY_PREFIX + eventId;

        // 1. [Infra Offloading]
        // 앱 메모리에서 중복 제거(Set)를 하지 않고, Redis에게 "지금 몇 종류 있어?"라고 물어봅니다.
        // 명령어: SCARD key
        Long uniqueTypes = redisTemplate.opsForSet().size(key); 
        
        if (uniqueTypes == null) uniqueTypes = 0L;

        // 2. [Business Logic]
        // N/2 (가져갈 수 있는 최대 한도) 계산
        long maxPickable = totalDropCount / 2;

        // 3. 결과 반환 (Math.min 로직 유지)
        return Math.min(uniqueTypes, maxPickable);
    }
    
    // 참고: 아이템이 드롭될 때마다 Redis에 비동기로 넣는 로직
    public void recordDrop(String eventId, String itemType) {
        // 명령어: SADD key member
        // 중복이면 알아서 무시하고, 새로운 종류면 저장함.
        redisTemplate.opsForSet().add(KEY_PREFIX + eventId, itemType);
    }
}
```

---

#### **4. 🧪 촘촘한 예외 처리 (Edge Case)**

인프라를 도입했을 때 발생할 수 있는 문제는 코딩 테스트의 예외 상황과는 다릅니다.

1. **네트워크 타임아웃 (Network Latency):**
    
    - Redis `size()`(SCARD) 명령어는 매우 빠르지만($O(1)$), 네트워크 연결이 불안정하면 예외가 발생할 수 있습니다. `try-catch`로 감싸고, 실패 시 기본값(0)을 리턴하거나 로그를 남겨야 합니다.
        
2. **키 만료 (TTL - Time To Live):**
    
    - Redis는 메모리 저장소이므로 영구 저장되지 않습니다. 이벤트가 끝나면 데이터가 자동으로 삭제되도록 `expire` 시간을 반드시 설정해야 합니다. 안 그러면 메모리 누수(Memory Leak)가 발생합니다.
        
3. **동시성 이슈 (Concurrency):**
    
    - 아이템 드롭(`recordDrop`)과 조회(`analyzeDropVariety`)가 동시에 일어날 때, 아주 미세한 시차로 개수가 달라질 수 있습니다. 하지만 통계용 데이터이므로 **'최종적 일관성(Eventual Consistency)'**을 허용한다고 합의하는 것이 일반적입니다.
        

---

#### **5. 📝 퇴근 전 'Todo 리스트' (Dev Process)**

이제 사수와 미팅이 끝났으니, 자리로 돌아가서 다음 순서로 개발을 진행하세요.

1. **요구사항/설계:**
    
    - Redis Key 설계 (`game:drop:{yyyyMMdd}`) 및 만료 시간(TTL) 정책 결정 (예: 24시간).
        
2. **데이터 접근 (Repository):**
    
    - `RedisTemplate` 설정 및 `SADD`(추가), `SCARD`(개수 조회) 메서드 래핑.
        
3. **비즈니스 로직 (Service):**
    
    - `analyzeDropVariety` 메서드 구현 (위의 코드 참조).
    - 기존 `nums` 배열을 루프 돌리는 코드는 **삭제** (또는 테스트 코드로 이동).
        
4. **API/DTO (Controller):**
    
    - 프론트엔드(대시보드)에서 호출할 API 엔드포인트 생성 (`GET /api/v1/drops/analysis`).
        
