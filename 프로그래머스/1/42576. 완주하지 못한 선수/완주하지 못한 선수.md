```python
# 모든 배열, 한명뺀 배열을 받고 그 한명을 찾아라
# 같은이름이더라도, 각각 기록한다.

#먼저 10의 6승의 입력이므로, NlogN이하의 시간복잡도를 사용해야한다.(정렬가능)
#없다는 걸 알려면, 결국 완주자명단과 전체명단을 비교해야한다.
#sort로 정렬한다면, 무조건 nlogn이다 좀더 줄일순 없을까?

#전체명단을 테이블에 넣고 완주자 명단으로 접근한다면
    #삭제연산으로 비교를 진행하고, 최종적으로 남은걸 반환
#완주자명단을 테이블에 넣고 전체명단으로 접근한다면
    #동일인이 있는경우에만 삭제연산을 진행한다
    # 테이블에 이름이 없다면 반환,
#전체 명단으로 접근하는게 끝까지 계산 안할 가능성이 존재한다.

def solution(participant, completion):
    dictcompletion={}
    answer = ''
#1.받은 완주자배열을 키는 이름, 값은 인원으로 테이블에 저장한다
    for name in completion:
        if name in dictcompletion:
            dictcompletion[name]+=1
        else: dictcompletion[name]=1
#2.전체명단을 순회하여, 완주자테이블과 비교한다.
    for i, name in enumerate(participant): 
    #만일 일치하지 않는다면, 반환해 종료
        if name not in dictcompletion:
            answer = name
            break 
    #만약 일치한다면 1일땐 삭제, 2이상일땐 감소
        elif 1<dictcompletion[name]:
            dictcompletion[name]-=1
        else: dictcompletion.pop(name)
    return answer
```

해시(Hash) 알고리즘의 핵심인 '검색 속도 최적화'에 집중하여 문제를 잘 푸셨네요. 파이썬의 딕셔너리를 활용해 $O(N)$ 시간 복잡도로 해결한 접근 방식은 아주 좋습니다.

하지만, **"변수 작명"**과 **"자료구조 활용의 세련미"** 측면에서 몇 가지 다듬을 점이 보입니다. 10년 차 사수의 시선으로 꼼꼼하게 리뷰해 드리겠습니다.

---

### [1단계 답변] : 제출된 코드 분석 및 CS 검증

#### **1. ⚔️ 코딩 테스트 관점 비판**

- **시간 복잡도:** 성공. 입력값 $N$이 최대 10만일 때, `participant`와 `completion`을 각각 한 번씩 순회하므로 $O(N)$입니다. 제한 시간 내에 충분히 통과합니다.
- **공간 복잡도:** 성공. `completion` 배열 크기만큼의 해시 테이블(`dictcompletion`) 공간이 필요하므로 $O(N)$입니다.
- **로직 정확성:** 동명이인을 처리하기 위해 **Count(개수)**를 저장한 방식은 정확합니다. 단순히 존재 여부(Boolean)만 체크했다면 틀렸을 겁니다.
    

#### **2. 💩 실무 코드 관점 리뷰 (Clean Code)**

이 코드를 PR(Pull Request)로 올렸다면 다음과 같은 피드백을 받았을 겁니다.

- **헝가리안 표기법 지양 (`dictcompletion`):**
    - 변수명에 자료형(`dict`)을 적는 건 옛날 방식입니다. 나중에 자료구조가 바뀌면 변수명도 바꿔야 하니까요.
    - **수정 제안:** `completionCounts` 혹은 `finisherMap`처럼 **데이터의 의미**를 담으세요.
- **불필요한 인덱스 생성 (`enumerate`):**
    - `for i, name in enumerate(participant):`에서 `i`는 전혀 사용되지 않습니다.
    - **수정 제안:** 그냥 `for name in participant:`로 작성하거나, 굳이 인덱스가 필요 없다면 `enumerate`를 제거하세요. 파이썬스러운(Pythonic) 코드가 아닙니다.
- **조건문의 가독성:**
    - `elif 1 < dictcompletion[name]:` 조건은 로직상 맞지만, "값이 남아있으면 차감한다"는 의미가 한눈에 들어오지 않습니다. 로직을 단순화할 필요가 있습니다.
        

#### **3. 🧠 CS 기본기 검증 (Why & Principle)**

면접관이 이 코드를 보고 추가로 던질 수 있는 질문입니다.

> **Q1. 해시 테이블(Hash Table)에서 '해시 충돌(Hash Collision)'이 발생하면 어떻게 처리되나요?**
>
> **A:** 해시 충돌이 발생하면 대표적으로 두 가지 방법으로 해결합니다.
>
> 1. **Chaining (체이닝):** 같은 해시 버킷에 연결 리스트(Linked List)로 데이터를 줄줄이 연결하는 방식입니다. (Java, Python 등이 주로 사용)
>     
> 2. **Open Addressing (개방 주소법):** 비어 있는 다른 버킷을 찾아 데이터를 저장하는 방식입니다.
>     

> **Q2. `participant`의 크기가 매우 커서 해시 테이블의 조회 성능이 $O(N)$으로 떨어지는 '최악의 경우'는 언제인가요?**
>
> **A:** 모든 키(선수 이름)가 **동일한 해시 값**을 가져서, 하나의 버킷에 모든 데이터가 몰리는 경우입니다. 이때는 해시 테이블이 사실상 연결 리스트처럼 동작하게 되어 검색 속도가 $O(1)$에서 $O(N)$으로 느려집니다.

#### **4. 💎 코딩 테스트용 모범 답안 (Modern Java)**

자바에서는 `HashMap`을 사용하며, `getOrDefault` 메서드가 핵심입니다.



```Java
import java.util.HashMap;
import java.util.Map;

class Solution {
    public String solution(String[] participant, String[] completion) {
        String answer = "";
        // 1. HashMap 사용: Key(이름) -> Value(카운트)
        // Python의 딕셔너리와 같은 역할입니다.
        Map<String, Integer> completionMap = new HashMap<>();

        // 2. 완주자 명단 해싱 (getOrDefault로 Null 처리 간소화)
        // Python: dictcompletion.get(name, 0) + 1 과 동일
        for (String player : participant) {
            completionMap.put(player, completionMap.getOrDefault(player, 0) + 1);
        }

        // 3. 완주자 처리 (카운트 차감)
        for (String player : completion) {
            completionMap.put(player, completionMap.get(player) - 1);
        }

        // 4. 값이 0이 아닌 사람(완주하지 못한 1명) 찾기
        // EntrySet을 순회하여 효율적으로 찾습니다.
        for (Map.Entry<String, Integer> entry : completionMap.entrySet()) {
            if (entry.getValue() > 0) { // 완주자 명단에 없거나 부족한 경우
                answer = entry.getKey();
                break;
            }
        }
        return answer;
    }
}
```

- 향상된 for문: 배열에서 문자열을 하나씩 꺼내어 player라는 변수에 담고 반복문을 실행하라
	- 파이썬 `for player in participant:`와 동일한기능
- **`getOrDefault(player, 0)`**: Map에 이름이 이미 있으면 그 값을 가져오고, 없으면 `0`을 가져오라는 아주 유용한 함수입니다.
---
### [2단계 답변] : 🚨 신입 사원 업무 시뮬레이션 (Junior Reality)

**"자, 신입 사원님! 코테에선 딕셔너리가 정답이었지만, 실무 서버 아키텍처에서 이 코드를 그대로 쓰면 **'동시성 이슈(Concurrency Issue)'**로 데이터가 꼬이게 됩니다. 인프라에게 이 짐을 덜어줍시다."**

---

#### **1. 🏢 업무 배경 파악 (Context)**

신입 사원님이 맡은 업무는 마라톤 완주 확인이 아니라, **"대규모 컨퍼런스 실시간 입장 확인 시스템"** 개발입니다.

- **상황:** 10만 명의 사전 등록자(Participant)가 행사장 게이트를 통과(Completion)하고 있습니다.
- **요구사항:** "현재 행사장에 도착하지 않은 사람(No-Show)"을 실시간으로 관리자 대시보드에 띄워야 합니다.
- **문제점:** 서버는 1대가 아니라 여러 대(Scale-out)로 분산되어 있습니다. 신입 사원님이 짠 파이썬 코드(`dictcompletion`)는 **서버 메모리(RAM)**에만 존재하므로, 서버 A로 입장한 사람을 서버 B는 알 수 없습니다.
    

#### **2. 💡 사수의 귓속말 (Engineer's Mindset: Offloading)**

- **알고리즘 vs 인프라:**
    - "지금 작성하신 `dictcompletion` 딕셔너리는 **Local In-Memory** 방식입니다. 서버가 재부팅되면 데이터가 다 날아가고, 서버 간 데이터 공유도 안 됩니다."
    - "이 로직은 애플리케이션 레벨에서 `for`문을 돌릴 게 아니라, **`Redis(In-Memory DB)`**에게 위임해야 합니다."
- **판단의 기준:**
    - **정합성(Consistency):** 여러 게이트에서 동시에 입장 처리가 일어납니다. Redis는 싱글 스레드 기반이라 **Race Condition(경쟁 상태)** 없이 카운팅/집합 연산이 가능합니다.
    - **속도(Latency):** 디스크 기반인 RDBMS(MySQL)로 실시간 차집합 연산을 하면 느립니다. 메모리 기반인 Redis가 적합합니다.
    - **식별자 변경:** 실무에선 '동명이인'을 이름으로 구분하지 않습니다. **`userId` (Unique Key)**를 사용하므로 로직이 훨씬 심플해집니다.
        

#### **3. 🛠️ 기술적 의사결정 (Architecture Decision)**

이 문제는 **`[Caching Layer (Redis)의 Set 자료구조]`**를 사용하는 것이 정석입니다.

신입 사원님이 파이썬으로 짠 `O(N)` 비교 로직은 Redis의 **집합 연산(Set Operation)** 명령어 하나로 대체됩니다. 복잡한 코드가 사라지는 마법을 보시죠.

**[AS-IS] 신입 사원님의 코드 (Python Application Logic)**



```Python
# 서버 메모리를 사용 -> 서버 확장 시 데이터 불일치 발생
def solution(participant, completion):
    # … 딕셔너리 만들고, for문 돌리고, 빼고 …
    # 코드가 길고 복잡함
    return answer
```

**[TO-BE] Redis 인프라 위임 (Spring Boot/Java Pseudo Code)**


```Java
// RedisTemplate을 주입받아 사용한다고 가정
public Set<String> getNoShowUsers(String eventId) {
    String allUsersKey = "event:" + eventId + ":registered"; // 참가자 전체 (Set)
    String enteredUsersKey = "event:" + eventId + ":entered"; // 입장한 사람 (Set)

    // 핵심 로직: 내 코드의 복잡한 for문/if문이 이 한 줄로 끝납니다.
    // SDIFF: 첫 번째 Set에는 있고, 두 번째 Set에는 없는 멤버를 반환 (차집합)
    return redisTemplate.opsForSet().difference(allUsersKey, enteredUsersKey);
}
```

- **Redis 명령어 매핑:**
    - 참가자 등록: `SADD event:100:registered "user_uuid_1"`
    - 입장 처리: `SADD event:100:entered "user_uuid_1"`
    - **미완주자 조회:** `SDIFF event:100:registered event:100:entered`

> [!NOTE]- 상세
>
> 이 코드는 **"ID(주소)를 줄 테니, 창고(Redis)에 저장된 데이터들끼리 직접 비교해서 결과만 나에게 보내라"**는 명령을 수행하는 것입니다.
> ### 1. `eventId`의 정체와 역할
>
> **`eventId`**는 메서드 호출 시 인자로 전달되는 **단순 문자열(String)** 식별자입니다.
>
> - **입력값 예시:** `"EVT_2025_001"`
> - **핵심 논리:** 이 문자열 자체가 수천 명의 데이터를 들고 있는 것이 아닙니다. 이 문자열은 Redis 서버 내부에 **이미 구축된 데이터 집합을 찾아내기 위한 '검색 인덱스'의 핵심 키워드**로 사용됩니다.
>     
> 
> ---
>
> ### 2. 코드 라인별 상세 분석
>
> #### **Line 1: `String allUsersKey = "event:" + eventId + ":registered";`**
>
> - **동작:** 입력받은 `eventId`를 조합하여 **Redis 키(Key)** 문자열을 생성합니다.
> - **데이터 구조:** 생성된 문자열(예: `"event:EVT_2025_001:registered"`)은 Redis 메모리 공간의 특정 지점을 가리키는 **고유 주소**가 됩니다.
> - **상태:** 이 주소값에 해당하는 Redis 서버 공간에는 이미 다수의 유저 식별자(UUID, ID 등)가 **Set(집합)** 자료구조로 저장되어 있어야 합니다.
>     
> 
> #### **Line 2: `String enteredUsersKey = "event:" + eventId + ":entered";`**
>
> - **동작:** 실제 행사에 참여하여 '입장 처리'가 완료된 데이터들이 저장된 **또 다른 Redis 키**를 생성합니다.
> - **데이터 구조:** 첫 번째 키와는 별개의 메모리 주소를 가리키며, 여기에도 역시 입장 완료된 유저들의 식별자들이 집합 형태로 존재합니다.
>     
> 
> #### **Line 3: `return redisTemplate.opsForSet().difference(allUsersKey, enteredUsersKey);`**
>
> - **동작:** Java 서버가 Redis 서버로 `SDIFF` 명령과 함께 **두 개의 키(주소값)를 전달**합니다.
> - **기술적 핵심 (중요):**
>     - Java 서버는 수천 명의 데이터를 자기 메모리로 가져오지 않습니다. **"A 주소와 B 주소의 차집합을 계산해라"**라는 명령어만 보냅니다.
>     - **Redis 엔진**은 메모리 내부에서 두 주소에 연결된 집합 데이터를 직접 대조합니다.
>     - 첫 번째 집합에는 존재하지만 두 번째 집합에는 없는 원소들(즉, 신청은 했으나 입장은 안 한 노쇼 유저)을 추출합니다.
> - **결과값 반환:** 연산이 끝난 최종 결과 리스트만 Java 서버의 `Set<String>` 형태로 반환됩니다.
>     
> 
> ---
>
> ### 3. "어떻게 하나만 들어오는데 전체를 담는가?"의 기술적 해답
>
> 1. **데이터 저장의 선행:** 이 메서드가 실행되기 전, 사용자가 예약하거나 입장할 때마다 Redis의 `SADD` 명령을 통해 해당 키(주소)에 유저 ID가 하나씩 **이미 누적 저장**되어 있습니다.
> 2. **포인터 개념:** Java 서버에서 다루는 `allUsersKey`는 실제 데이터 덩어리가 아니라, Redis라는 외부 저장소에 있는 **데이터 뭉치를 가리키는 '포인터(지정자)'** 역할을 합니다.
> 3. **연산의 주체:** 비교 연산을 수행하는 주체가 Java 어플리케이션이 아닌 **Redis 서버 엔진**이기 때문에, Java 코드는 주소값만 던져주고 결과만 받는 구조가 가능합니다.
>     

#### **4. 🧪 촘촘한 예외 처리 (Edge Case)**

인프라를 도입했을 때 발생할 수 있는 새로운 문제들입니다.

1. **대용량 키 처리 (Block Issue):**
    
    - 등록자가 10만 명이 아니라 **1,000만 명**이라면? `SDIFF` 명령어는 실행되는 동안 Redis의 다른 작업을 모두 멈춥니다(Block).
    - **해결:** 실무에선 `SDIFF`를 바로 때리지 않고, `SSCAN`으로 데이터를 쪼개서 가져오거나 별도 배치(Batch) 서버에서 비동기로 계산합니다.
        
2. **데이터 만료 (TTL):**
    
    - 행사가 끝났는데 Redis 메모리를 계속 차지하면 돈 낭비입니다.
    - **해결:** 키를 생성할 때 `EXPIRE event:100:registered 86400` (24시간 후 삭제)을 반드시 설정합니다.
        
3. **네트워크 실패:**
    
    - Redis가 순간적으로 연결이 끊기면?
    - **해결:** DB(MySQL)에 원본 데이터가 있어야 합니다. Redis는 '캐시' 용도이고, 실제 입장 로그는 DB에도 비동기로 저장하여 데이터 유실을 방지합니다. (Write-Behind 전략)
        

#### **5. 📝 퇴근 전 'Todo 리스트' (Dev Process)**

자, 이제 회의실에서 나가 자리로 돌아가서 이 순서대로 작업하세요.

1. **요구사항/설계:**
    
    - "동명이인 처리는 `UserId`로 대체한다"는 정책 확정.
    - Redis Key 설계 (`event:{id}:registered`, `event:{id}:entered`) 문서화.
        
2. **API/DTO:**
    
    - `POST /api/events/{id}/enter` (입장 처리 API)
    - `GET /api/events/{id}/no-show` (미입장자 조회 API) Controller 스텁 코드 작성.
        
3. **비즈니스 로직:**
    
    - Redis `SADD`로 입장 처리 구현.
    - Redis `SDIFF`로 미입장자 조회 로직 구현 (기존 `HashMap` 로직 제거).
        
4. **데이터 접근:**
    
    - `RedisRepository` 혹은 `RedisTemplate` 설정 및 테스트 코드 작성.
        

---

사수의 한마디:

"신입님, 이제 HashMap을 직접 구현하는 대신 **'이미 구현된 고성능 Map(Redis)'**을 호출하는 법을 배우셨네요. 이게 바로 코더와 엔지니어의 차이입니다. 오늘 저녁에 Redis 설치부터 해볼까요?"
