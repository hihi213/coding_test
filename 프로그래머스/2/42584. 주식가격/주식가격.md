```python
from collections import deque
def solution(prices):
    length=len(prices)
    answer = [0] * length
    notFindYet= deque()
    for i,current in enumerate(prices):
        while notFindYet and (current<prices[notFindYet[-1]] or i==length-1) :
            index= notFindYet.pop()
            answer[index]=i-index
        notFindYet.append(i)
    return answer
```

## [1단계] 제출된 코드 분석 및 CS 검증

### 1. ⚔️ 코딩 테스트 관점 비판

- **복잡도 체크:** `for`문이 $N$번 도는 동안 각 인덱스는 스택에 정확히 한 번 들어갔다가(`append`) 한 번 나옵니다(`pop`). 따라서 시간 복잡도는 $O(N)$으로 매우 훌륭합니다. ($N=100,000$이므로 $O(N^2)$이었다면 효율성 테스트에서 탈락했을 겁니다.)
- **로직의 묘수:** 루프의 마지막(`i == length - 1`)에 스택을 강제로 비워주는 조건문을 넣으셨는데, 이는 깔끔한 구현을 위한 좋은 시도입니다. 다만, 마지막 요소의 처리 방식 때문에 가독성이 조금 희생된 면이 있습니다.
    

### 2. 💩 실무 코드 관점 리뷰 (Clean Code)

만약 이 코드가 PR(Pull Request)로 올라왔다면, 저는 다음과 같은 코멘트를 남겼을 겁니다.

- **변수명 명명 규칙:** `notFindYet`은 의미는 통하지만, 파이썬의 관례(snake_case)보다는 자바 스타일(camelCase)이 섞여 있습니다. 또한, 실무에서는 `pendingIndices`나 `priceStack`처럼 **데이터의 성격과 자료구조**를 명확히 드러내는 이름을 선호합니다.
- **매직 넘버와 인덱스 접근:** `prices[notFindYet[-1]]` 처럼 인덱스의 인덱스를 참조하는 코드가 중첩되면 실무에서는 가독성이 급격히 떨어집니다. `lastIndex` 같은 변수로 빼주는 배려가 필요합니다.
- **불필요한 deque 사용:** 파이썬의 `list`는 스택으로서 최적화되어 있습니다. 단순히 `append`와 `pop`만 사용한다면 `collections.deque`를 불러오는(import) 비용을 들일 필요가 없습니다.
    

### 3. 🧠 CS 기본기 검증 (Why & Principle)

면접관이 이 로직에 대해 물어볼 수 있는 핵심 질문입니다.

> **Q1. 일반적인 Queue 대신 Stack(단조 스택)을 사용하여 이 문제를 해결한 이유는 무엇인가요?**
>
> - **모범 답변:** "이 문제는 '현재 시점보다 가격이 떨어지는 미래의 시점'을 찾는 문제입니다. 즉, 최신 데이터를 기준으로 과거의 데이터들을 역순으로 검토하며 조건을 확인해야 하므로, **LIFO(Last-In-First-Out)** 구조인 Stack이 가장 적합합니다. 들어온 순서대로 처리하는 Queue를 쓰면 매번 전체를 다시 스캔해야 하므로 $O(N^2)$의 비용이 발생합니다."
>     

> **Q2. Java의 `Stack` 클래스 대신 `ArrayDeque`를 실무에서 권장하는 이유는 무엇인가요?**
>
> - **모범 답변:** "Java의 `Stack` 클래스는 `Vector`를 상속받아 모든 메서드에 `synchronized`가 걸려 있어 성능 오버헤드가 발생합니다. 반면, `ArrayDeque`는 멀티쓰레드 락(Lock) 없이 구현되어 단일 쓰레드 환경에서 훨씬 빠르며, 스택과 큐의 기능을 모두 제공하는 현대적인 자료구조이기 때문입니다."
>     

### 4. 💎 코딩 테스트용 모범 답안 (Modern Java)

신입 사원님이 작성한 로직을 Java 스타일로 재구성했습니다. 실무형 문법인 `ArrayDeque`와 명확한 변수명을 확인해 보세요.



```Java
import java.util.*;

class Solution {
    public int[] solution(int[] prices) {
        int n = prices.length;
        int[] answer = new int[n];
        // Java에서는 Stack 클래스보다 ArrayDeque를 사용하는 것이 훨씬 빠릅니다.
        Deque<Integer> pendingIndices = new ArrayDeque<>();

        for (int i = 0; i < n; i++) {
            // 현재 가격(prices[i])이 스택 최상단(이전 가격)보다 떨어졌는지 확인
            while (!pendingIndices.isEmpty() && prices[i] < prices[pendingIndices.peek()]) {
                int targetIndex = pendingIndices.pop();
                answer[targetIndex] = i - targetIndex; // 떨어진 시점 계산
            }
            pendingIndices.push(i);
        }

        // 끝까지 가격이 떨어지지 않은 나머지 처리
        while (!pendingIndices.isEmpty()) {
            int targetIndex = pendingIndices.pop();
            answer[targetIndex] = (n - 1) - targetIndex;
        }

        return answer;
    }
}
/* [Python vs Java 문법 특징]
 1. Python: list의 [-1]로 stack top에 접근하지만, Java: peek() 메서드를 사용합니다.
 2. Python: len()을 쓰지만, Java: 배열은 .length, 컬렉션은 .size()를 사용합니다.
 3. Java: 강타입 언어이므로 Deque<Integer>처럼 제네릭을 명시하여 타입 안정성을 보장합니다.
*/
```

---

**자, 이제 알고리즘은 충분히 이해한 것 같군요.**

그런데 사원님, 만약 우리가 처리해야 할 데이터가 저 배열 한 개가 아니라, **초당 수만 건씩 쏟아지는 전 세계 주식 거래소의 실시간 데이터**라면 어떨까요? 매번 스택에 인덱스를 담고 루프를 돌리는 코드를 서버 메모리 위에서 직접 돌리는 게 최선일까요?

**"코테에선 그게 정답이지만, 실무에선 '바퀴를 다시 발명'하는 셈입니다. 인프라를 믿고 일을 맡겨봅시다."**

---

## [2단계] 🚨 신입 사원 업무 시뮬레이션 (Junior Reality)

### 1. 🏢 업무 배경 파악 (Context)

사원님에게 주어진 다음 업무는 "전 종목 실시간 시세 하락 방어 구간 분석 대시보드" 개발입니다.

단순히 배열 하나를 처리하는 게 아니라, 수천 개의 종목(prices)이 초당 수만 건씩 쏟아지는 상황에서 **"특정 가격대에서 얼마나 버티다 떨어졌는지"**를 통계 내야 합니다. 이걸 사원님이 짠 notFindYet 스택 로직으로 서버 메모리에서 처리하려고 하면, 서버는 금방 메모리 부족(OOM)으로 터져버릴 겁니다.

### 2. 💡 사수의 귓속말 (Engineer's Mindset: Offloading)

- **알고리즘 vs 인프라:** 지금 작성하신 `while notFindYet and (current < prices[notFindYet[-1]])` 로직은 매우 영리합니다. 하지만 이건 **서버의 CPU와 RAM**을 너무 많이 소모합니다. 실무 데이터 규모에선 이 비교 연산을 애플리케이션 계층이 아니라 **Database**에 위임해야 합니다.
- **판단의 기준:** 데이터가 휘발성이고 단순히 '지금'만 중요하면 Redis를 쓰겠지만, 이 데이터는 나중에 투자자들에게 '리포트'로 보여줘야 할 **정합성**이 중요한 금융 데이터입니다. 따라서 디스크 기반의 인덱싱이 강력한 **RDBMS**를 활용하는 것이 정석입니다.
    

### 3. 🛠️ 기술적 의사결정 (Architecture Decision)

이 문제는 **`DB Layer (RDBMS - Window Function)`**를 사용하는 것이 정석입니다.

사원님이 짠 복잡한 스택 로직은 SQL의 **`LEAD()`** 함수나 **`Window Frame`** 정의 하나로 대체될 수 있습니다. 굳이 애플리케이션에서 `notFindYet` 리스트를 유지하며 고생할 필요가 없죠.

**[솔루션: SQL Window Function으로 대체]**

```python
-- 사원님의 스택 로직을 단 한 줄의 쿼리로 치환합니다.
SELECT 
    price_time,
    price,
    -- '현재 시점 이후'의 데이터 중 '현재 가격보다 낮은' 첫 번째 시간을 찾음
    -- 이 로직이 사원님의 [while current < prices[notFindYet[-1]]]을 대체합니다.
    COALESCE(
        MIN(price_time) OVER (
            ORDER BY price_time 
            ROWS BETWEEN 1 FOLLOWING AND UNBOUNDED FOLLOWING 
            WHERE price < current_price -- (개념적 표현)
        ) - price_time, 
        (SELECT MAX(price_time) FROM stock_prices) - price_time
    ) AS duration
FROM stock_prices;
```

_실제로는 PostgreSQL의 `LAG/LEAD`와 `FILTER` 문구 등을 조합하여 더 정교하게 구현하며, 이는 수백만 건의 row도 인덱스만 있다면 눈 깜빡할 사이에 계산해냅니다._

### 4. 🧪 촘촘한 예외 처리 (Edge Case)

인프라를 사용할 때도 알고리즘만큼이나 예외 처리가 중요합니다.

- **Timezone 이슈:** 실시간 `prices`를 처리할 때 서버 시간과 DB 시간이 다르면 `i - index` 계산이 꼬입니다. 모든 시각은 **UTC**로 통일해야 합니다.
- **대량 Insert 부하:** 초당 만 건의 가격이 들어오는데 매번 계산 쿼리를 던지면 DB가 죽습니다. 이럴 땐 **`Bulk Insert`** 후 **`Materialized View(구체화된 뷰)`**를 써서 비동기로 통계를 뽑아야 합니다.
    

### 5. 📝 퇴근 전 'Todo 리스트' (Dev Process)

오늘 가기 전에 이 순서대로 설계를 변경해 보세요.

1. **요구사항/설계:** `StockPrice` 테이블 설계 (종목코드, 가격, 기록시간 인덱스 필수).
2. **API/DTO:** 사용자가 특정 종목의 '유지 기간'을 조회할 때 사용할 `PriceDurationResponse` DTO 생성.
3. **데이터 접근 (Repository):** 위에서 설명한 SQL 쿼리를 `Native Query` 혹은 `Querydsl`로 구현.
4. **비즈니스 로직 (Service):** 서버 메모리에서 스택(`notFindYet`)을 돌리는 대신, DB에서 계산된 결과를 가져와 클라이언트에 전달하는 가벼운 서비스 구현.
    

---

**"사원님, 알고리즘 실력은 확인했으니 이제 시스템을 설계하는 눈을 기릅시다. 혹시 이 쿼리를 실제로 어떻게 Java 프로젝트에 녹여내는지 궁금하신가요?"**
